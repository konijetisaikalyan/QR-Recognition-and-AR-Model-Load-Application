import { ISceneLoaderProgressEvent } from '@babylonjs/core/Loading/sceneLoader.js';
import { AbstractMesh } from '@babylonjs/core/Meshes/abstractMesh.js';
import React, { ReactNode } from 'react';
import { FiberAbstractMeshProps, FiberAbstractMeshPropsCtor } from '../generatedProps';
import { ILoadedModel } from '../hooks/loaders/loadedModel';
export type ModelProps = {
    /**
     * Only used on init.  Will not update dynamically (scaling will update dynamically and override this)
     * An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
     */
    meshNames?: any;
    receiveShadows?: boolean;
    rootUrl: string;
    sceneFilename: string;
    pluginExtension?: string;
    alwaysSelectAsActiveMesh?: boolean;
    reportProgress?: boolean;
    scaleToDimension?: number;
    onModelLoaded?: (model: ILoadedModel) => void;
    onModelError?: (message: string, exception?: any) => void;
    onLoadProgress?: (event: ISceneLoaderProgressEvent) => void;
    onCreated?: (rootMesh: AbstractMesh) => void;
} & FiberAbstractMeshProps & FiberAbstractMeshPropsCtor & {
    children?: ReactNode | undefined;
};
declare const Model: React.ForwardRefExoticComponent<{
    /**
     * Only used on init.  Will not update dynamically (scaling will update dynamically and override this)
     * An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
     */
    meshNames?: any;
    receiveShadows?: boolean;
    rootUrl: string;
    sceneFilename: string;
    pluginExtension?: string;
    alwaysSelectAsActiveMesh?: boolean;
    reportProgress?: boolean;
    scaleToDimension?: number;
    onModelLoaded?: (model: ILoadedModel) => void;
    onModelError?: (message: string, exception?: any) => void;
    onLoadProgress?: (event: ISceneLoaderProgressEvent) => void;
    onCreated?: (rootMesh: AbstractMesh) => void;
} & {
    actionManager?: import("@babylonjs/core").AbstractActionManager;
    alphaIndex?: number;
    alwaysSelectAsActiveMesh?: boolean;
    applyFog?: boolean;
    bakedVertexAnimationManager?: import("@babylonjs/core").IBakedVertexAnimationManager;
    checkCollisions?: boolean;
    collisionGroup?: number;
    collisionMask?: number;
    collisionResponse?: boolean;
    collisionRetryCount?: number;
    computeBonesUsingShaders?: boolean;
    cullingStrategy?: number;
    definedFacingForward?: boolean;
    doNotSyncBoundingInfo?: boolean;
    edgesColor?: import("@babylonjs/core").Color4;
    edgesWidth?: number;
    ellipsoid?: import("@babylonjs/core").Vector3;
    'ellipsoid-x'?: number;
    'ellipsoid-y'?: number;
    'ellipsoid-z'?: number;
    ellipsoidOffset?: import("@babylonjs/core").Vector3;
    'ellipsoidOffset-x'?: number;
    'ellipsoidOffset-y'?: number;
    'ellipsoidOffset-z'?: number;
    enableDistantPicking?: boolean;
    enableEdgesRendering?: any;
    enablePointerMoveEvents?: boolean;
    facetDepthSortFrom?: import("@babylonjs/core").Vector3;
    hasVertexAlpha?: boolean;
    inheritVisibility?: boolean;
    instancedBuffers?: {
        [key: string]: any;
    };
    isBlocker?: boolean;
    isNearGrabbable?: boolean;
    isNearPickable?: boolean;
    isPickable?: boolean;
    isVisible?: boolean;
    layerMask?: number;
    material?: import("@babylonjs/core").Material;
    morphTargetManager?: import("@babylonjs/core").MorphTargetManager;
    mustDepthSortFacets?: boolean;
    numBoneInfluencers?: number;
    onCollide?: (collidedMesh?: AbstractMesh) => void;
    onCollideObservable?: any;
    onCollisionPositionChange?: () => void;
    onCollisionPositionChangeObservable?: any;
    onMaterialChangedObservable?: any;
    onRebuildObservable?: any;
    outlineColor?: import("@babylonjs/core").Color3;
    outlineWidth?: number;
    overlayAlpha?: number;
    overlayColor?: import("@babylonjs/core").Color3;
    partitioningBBoxRatio?: number;
    partitioningSubdivisions?: number;
    pointerOverDisableMeshTesting?: boolean;
    rawBoundingInfo?: import("@babylonjs/core").BoundingInfo;
    receiveShadows?: boolean;
    renderingGroupId?: number;
    setBoundingInfo?: any;
    setIndices?: any;
    setMaterialForRenderPass?: any;
    setVerticesData?: any;
    showSubMeshesBoundingBox?: boolean;
    skeleton?: import("@babylonjs/core").Skeleton;
    subMeshes?: import("@babylonjs/core").SubMesh[];
    surroundingMeshes?: AbstractMesh[];
    useOctreeForCollisions?: boolean;
    useOctreeForPicking?: boolean;
    useOctreeForRenderingSelection?: boolean;
    useVertexColors?: boolean;
    visibility?: number;
} & {
    addChild?: any;
    addRotation?: any;
    billboardMode?: number;
    ignoreNonUniformScaling?: boolean;
    infiniteDistance?: boolean;
    onAfterWorldMatrixUpdateObservable?: any;
    position?: import("@babylonjs/core").Vector3;
    preserveParentRotationForBillboard?: boolean;
    reIntegrateRotationIntoRotationQuaternion?: boolean;
    rotation?: import("@babylonjs/core").Vector3;
    rotationQuaternion?: import("@babylonjs/core").Quaternion;
    scaling?: import("@babylonjs/core").Vector3;
    scalingDeterminant?: number;
    setAbsolutePosition?: any;
    setDirection?: any;
    setParent?: any;
    setPivotMatrix?: any;
    setPivotPoint?: any;
    setPositionWithLocalVector?: any;
    setPreTransformMatrix?: any;
    translate?: any;
} & {
    accessibilityTag?: import("@babylonjs/core/IAccessibilityTag").IAccessibilityTag;
    addBehavior?: any;
    animationPropertiesOverride?: import("@babylonjs/core").AnimationPropertiesOverride;
    animations?: import("@babylonjs/core").Animation[];
    doNotSerialize?: boolean;
    id?: string;
    inspectableCustomProperties?: import("@babylonjs/core").IInspectable[];
    metadata?: any;
    name?: string;
    onAccessibilityTagChangedObservable?: any;
    onDispose?: () => void;
    onDisposeObservable?: any;
    onReady?: (node: import("@babylonjs/core").Node) => void;
    parent?: import("@babylonjs/core").Node;
    reservedDataStore?: any;
    setEnabled?: any;
    state?: string;
    uniqueId?: number;
} & import("../CustomProps").CustomProps & FiberAbstractMeshPropsCtor & {
    children?: ReactNode | undefined;
} & React.RefAttributes<AbstractMesh>>;
export default Model;
